#
# Defines method to plot graph in "the proper way".
#

import matplotlib.pyplot as plt
import cv2
import numpy as np

from os.path import join
from os import remove, listdir

# The folder in which to store outputs
OUTPUT_FOLDER = "out"


# Takes a list of tuples (title, image) and displays all of them in a single
# matplotlib figure, with one image per subplot. If the "save" flag is given, the figure
# is saved to disk instead of being displayed. The function does not return anything.
# The function has the following parameters:
#  	global_title: The title of the figure
# 	images: a list of tuples (title, image) to display. The images are expected to be either
# 			grayscale or BGR.
#	save: If True, the figure generated by the method is saved in the OUTPUT_FOLDER.
def display_photo_parallel(global_title, images, save=False):
	global OUTPUT_FOLDER

	# Settings of the figure
	fig = plt.figure(figsize=(15, 7), dpi=80)
	fig.suptitle(global_title)
	fig.subplots_adjust(left=0.01, bottom=0.01, right=0.99, top=0.95, wspace=0.02, hspace=0)

	curr = 1  # The current subplot being generated
	n = len(images)  # The total number of images
	rows = n // 3 + 1  # Number of rows in the figure
	cols = n if n < 3 else 3  # Number of columns in the figure

	for title, image in images:

		if image is not None:
			subp = fig.add_subplot(rows, cols, curr)
			curr += 1

			subp.set_title(title)
			subp.axis('off')

			# If the shape of an image has length two, the image is grayscale. Otherwise,
			# the image is expected to be in the BGR format.
			if 2 == len(image.shape):
				subp.imshow(image, cmap='gray')
			else:
				subp.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))

	if save:
		fig.savefig(join(OUTPUT_FOLDER, "{0}.png".format(global_title)))
	else:
		plt.show()


# Takes a list of tuples (title, image) and displays all of them in sequence,
# waiting for a keyboard input before switching to the next. If the "save" flag is given, the
# images are saved to disk instead of being displayed. The function does not return anything.
# The function has the following parameters:
# 	global_title: The title of the sequence
# 	images: a list of tuples (title, image) to display. The images are expected to be either
# 			grayscale or BGR.
#   save: If True, the images are saved in the OUTPUT_FOLDER.
def display_photo_sequential(global_title, images, save=False):
	global OUTPUT_FOLDER

	curr = 1  # The current image being shown

	if not save:
		cv2.namedWindow(global_title, cv2.WINDOW_NORMAL)
		cv2.resizeWindow(global_title, 1200, 650)

	for title, image in images:
		if save:
			cv2.imwrite(join(OUTPUT_FOLDER, "{0}-{1}-{2}.png".format(global_title, curr, title)), image)
		else:
			cv2.imshow(global_title, image)
			cv2.waitKey(0)
		curr += 1

	if not save:
		cv2.destroyWindow(global_title)


# Unfortunately, there are way to many intermediary frames to store in memory
# in order to be able to have a simple "display_video" method.
# This routine takes a global_title, which usually is the glyph name, a list of names,
# which usually contains the names of all the intermediaries, and a given output size.
# The method returns a list of cv2.VideoWriter correctly initialized and ready to write.
def create_output_video_streams(global_title, names, output_size):
	global OUTPUT_FOLDER
	output_format = cv2.VideoWriter_fourcc(*'MJPG')

	res = []
	curr = 0

	for name in names:
		path = join(OUTPUT_FOLDER, "{0}-{1}-{2}.avi".format(global_title, curr, name))
		curr += 1
		res.append(cv2.VideoWriter(path, output_format, 20.0, output_size))

	return res

# Takes a list of intermediary frames as produced by a single call to process_frame
# and a list of cv2.VideoWriter (with their output size). Writes each intermediary
# to the appropriate VideoWriter.
def write_intermediaries_to_videos(intermediary, outs, output_size):
	for interm, out in zip(intermediary, outs):
		tw = _img_resize(np.uint8(interm[1]), output_size)
		out.write(tw)


# Closes a list of cv2.VideoWriter
def close_output_video_streams(outs):
	for o in outs:
		o.release()


# Deletes all the files in the OUTPUT_FOLDER except for the .gitkeep file
def clean_output_folder():
	global OUTPUT_FOLDER

	filesToDelete = [join(OUTPUT_FOLDER, f) for f in listdir(OUTPUT_FOLDER) if not f.endswith(".gitkeep")]
	for f in filesToDelete:
		remove(f)






# KEEPS ASPECT RATIO takes image and returns it resized to the shape give to it
# retruns 3-channel  image resized to the shape given to it
def _img_resize(img, final_shape):

	if (img is not None) and (img.shape[0] == final_shape[1]) and (img.shape[1] == final_shape[0]):
		return img

	if (img is not None):
		if (img.shape[0]/img.shape[1] < final_shape[0]/final_shape[1]):
			targer_size = (int(round(img.shape[1] / img.shape[0] * final_shape[1])), final_shape[1])
			resized = cv2.resize(img, targer_size, interpolation = cv2.INTER_AREA)
			top_border = 0
			bottom_border = 0
			left_border = int(round((final_shape[0] - resized.shape[0]) / 2))
			right_border = final_shape[0] - targer_size[0] - left_border
		else:
			targer_size = (final_shape[0], int(round(img.shape[0] / img.shape[1] * final_shape[1])))
			resized = cv2.resize(img, targer_size, interpolation=cv2.INTER_AREA)
			top_border = int(round((final_shape[1] - resized.shape[1]) / 2))
			bottom_border = final_shape[1] - targer_size[1] - top_border
			left_border = 0
			right_border = 0
	else:
		resized = np.zeros((final_shape[1], final_shape[0]), dtype='uint8')
		top_border, bottom_border, left_border, right_border = 0,0,0,0

	if len(resized.shape) == 2:
		resized = cv2.cvtColor(resized, cv2.COLOR_GRAY2BGR)
	final = cv2.copyMakeBorder(resized, top=top_border, bottom=bottom_border, left=left_border, right=right_border, borderType= cv2.BORDER_CONSTANT, value=[0,0,0] )
	return final